---
title: Actualizaciones de estado en Zustand sin acciones en el store
description: Conoce una alternativa a la colocaciÃ³n tradicional en Zustand definir acciones fuera del store. Mejora el code splitting y elimina la necesidad de hooks para actualizar el estado.
---

## PrÃ¡ctica sin acciones dentro del store en Zustand

La prÃ¡ctica recomendada en Zustand es **colocar las acciones y el estado dentro del mismo store**, es decir, mantenerlos juntos y encapsulados.

### âœ… Ejemplo recomendado con colocaciÃ³n de acciones

```go:ts
export const useBoundStore = create((set) => ({
  count: 0,
  text: 'hello',
  inc: () => set((state) => ({ count: state.count + 1 })),
  setText: (text) => set({ text }),
}))
```

Este enfoque crea un store **autocontenible**, donde los datos y las acciones estÃ¡n centralizados en un solo lugar.

## ğŸš€ Enfoque alternativo: acciones externas al store

Otra forma vÃ¡lida de usar Zustand es **definir las acciones fuera del store**, a nivel de mÃ³dulo.

```go:ts
export const useBoundStore = create(() => ({
  count: 0,
  text: 'hello',
}))

export const inc = () =>
  useBoundStore.setState((state) => ({ count: state.count + 1 }))

export const setText = (text) => useBoundStore.setState({ text })
```

### ğŸ¯ Ventajas de este enfoque

- âœ… No necesitas un hook (`useBoundStore`) para llamar a una acciÃ³n.
- âœ… Facilita el **code splitting** (carga de cÃ³digo por partes).
- âœ… Mejora la organizaciÃ³n modular del cÃ³digo.

### âš–ï¸ Consideraciones

Aunque este patrÃ³n no presenta desventajas funcionales, **algunos desarrolladores prefieren la colocaciÃ³n** porque ofrece una estructura **mÃ¡s encapsulada y cohesionada**, especialmente Ãºtil en aplicaciones complejas o colaborativas.

Ambos enfoques son vÃ¡lidos. La elecciÃ³n depende de tu preferencia, el tamaÃ±o del proyecto y tus necesidades de arquitectura.
