---
title: Tic Tac Toe
description: En esta seccion Aprenderas a crear el juego de tic tac toe con zustand
---

## Construyendo un juego con React y Zustand

En este tutorial aprenderás a crear un pequeño juego de tres en línea (_tic-tac-toe_). Este tutorial asume que ya tienes conocimientos básicos de React.

Las técnicas que aprenderás son fundamentales para construir cualquier aplicación con React, y te darán una comprensión más profunda tanto de React como de Zustand al usarlos juntos.

Al finalizar, tendrás una aplicación funcional que combina un estado global sencillo con una interfaz interactiva, ideal para entender cómo manejar estados compartidos sin complicaciones.

## Estructura del tutorial

Este tutorial está dividido en varias secciones:

1. **Configuración inicial**: Te dará un punto de partida para seguir el tutorial sin problemas.
2. **Introducción a React**: Aprenderás los fundamentos de React: componentes, props y estado.
3. **Completar el juego**: Te enseñará las técnicas más comunes usadas en el desarrollo con React.
4. **Añadir viaje en el tiempo**: Te dará una visión más profunda sobre las ventajas únicas que ofrece React.

## ¿Que vas a construir?

En este tutorial, crearás un juego interactivo de **Tic-Tac-Toe (tres en línea)** utilizando **React y Zustand**. Al finalizar, tendrás:

- Un tablero interactivo.
- Manejo de turnos entre jugadores.
- Detección automática de ganador.
- Historial de movimientos con opción de "viajar en el tiempo".

Puedes ver cómo quedará al final aquí:

### 🧩 Codigo completo del ejemplo

```go:tsx
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

// --- Zustand Store ---
const useGameStore = create(
  combine(
    {
      history: [Array(9).fill(null)],
      currentMove: 0,
    },
    (set, get) => ({
      setHistory: (nextHistory) => {
        set((state) => ({
          history:
            typeof nextHistory === 'function'
              ? nextHistory(state.history)
              : nextHistory,
        }))
      },
      setCurrentMove: (nextCurrentMove) => {
        set((state) => ({
          currentMove:
            typeof nextCurrentMove === 'function'
              ? nextCurrentMove(state.currentMove)
              : nextCurrentMove,
        }))
      },
    }),
  ),
)

// --- Componentes React ---

function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 0,
        backgroundColor: '#fff',
        border: '1px solid #999',
        outline: 0,
        borderRadius: 0,
        fontSize: '1rem',
        fontWeight: 'bold',
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  )
}

function Board({ xIsNext, squares, onPlay }) {
  const winner = calculateWinner(squares)
  const turns = calculateTurns(squares)
  const player = xIsNext ? 'X' : 'O'
  const status = calculateStatus(winner, turns, player)

  function handleClick(i) {
    if (squares[i] || winner) return
    const nextSquares = squares.slice()
    nextSquares[i] = player
    onPlay(nextSquares)
  }

  return (
    <>
      <div style={{ marginBottom: '0.5rem' }}>{status}</div>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          width: 'calc(3 * 2.5rem)',
          height: 'calc(3 * 2.5rem)',
          border: '1px solid #999',
        }}
      >
        {squares.map((_, i) => (
          <Square
            key={`square-${i}`}
            value={squares[i]}
            onSquareClick={() => handleClick(i)}
          />
        ))}
      </div>
    </>
  )
}

export default function Game() {
  const history = useGameStore((state) => state.history)
  const setHistory = useGameStore((state) => state.setHistory)
  const currentMove = useGameStore((state) => state.currentMove)
  const setCurrentMove = useGameStore((state) => state.setCurrentMove)
  const xIsNext = currentMove % 2 === 0
  const currentSquares = history[currentMove]

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]
    setHistory(nextHistory)
    setCurrentMove(nextHistory.length - 1)
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove)
  }

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'row',
        fontFamily: 'monospace',
      }}
    >
      <div>
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div style={{ marginLeft: '1rem' }}>
        <ol>
          {history.map((_, historyIndex) => {
            const description =
              historyIndex > 0
                ? `Go to move #${historyIndex}`
                : 'Go to game start'

            return (
              <li key={historyIndex}>
                <button onClick={() => jumpTo(historyIndex)}>
                  {description}
                </button>
              </li>
            )
          })}
        </ol>
      </div>
    </div>
  )
}

// --- Funciones auxiliares ---

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ]

  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i]
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a]
    }
  }

  return null
}

function calculateTurns(squares) {
  return squares.filter((square) => !square).length
}

function calculateStatus(winner, turns, player) {
  if (!winner && !turns) return 'Draw'
  if (winner) return `Winner: ${winner}`
  return `Next player: ${player}`
}
```

Claro, aquí tienes tu explicación y código mejorado en **formato Markdown estructurado**, ideal para documentación, tutoriales o un archivo `README.md`.

## 🧱 Building the Board - Tic Tac Toe con React

Vamos a construir el tablero para nuestro juego de Tic Tac Toe. Comenzaremos con un componente `Square`, que será la unidad básica del tablero, seguido por el componente `Board` que organizará estos cuadrados en una cuadrícula 3x3.

### 🎯 Objetivo

- Crear un componente **`Square`** que represente una casilla del juego.
- Crear un componente **`Board`** que contenga 9 `Square` en una cuadrícula.

---

### 🟩 Componente `Square`

Este componente representa una sola casilla del tablero. Recibe dos props:

- `value`: el símbolo que se mostrará (`'X'`, `'O'`, o `null`).
- `onSquareClick`: función que se ejecuta cuando se hace clic en la casilla.

```go:jsx
// Square.jsx
export default function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 0,
        backgroundColor: '#fff',
        border: '1px solid #999',
        outline: 0,
        borderRadius: 0,
        fontSize: '1rem',
        fontWeight: 'bold',
        cursor: 'pointer',
        width: '2.5rem',
        height: '2.5rem',
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  )
}
```

> 💡 Este botón simula una celda cuadrada con diseño simple y responsivo.

---

### 🧩 Componente `Board`

El componente `Board` organiza 9 `Square` en una cuadrícula 3x3. En esta etapa inicial, asignamos valores estáticos a cada cuadrado para mostrar cómo se posicionan.

```go:jsx
// Board.jsx
import Square from './Square'

export default function Board() {
  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: 'repeat(3, 1fr)',
        width: 'calc(3 * 2.5rem)',
        height: 'calc(3 * 2.5rem)',
        border: '1px solid #999',
      }}
    >
      <Square value="1" onSquareClick={() => {}} />
      <Square value="2" onSquareClick={() => {}} />
      <Square value="3" onSquareClick={() => {}} />
      <Square value="4" onSquareClick={() => {}} />
      <Square value="5" onSquareClick={() => {}} />
      <Square value="6" onSquareClick={() => {}} />
      <Square value="7" onSquareClick={() => {}} />
      <Square value="8" onSquareClick={() => {}} />
      <Square value="9" onSquareClick={() => {}} />
    </div>
  )
}
```

> ⚠️ En este punto, los valores `'1'` a `'9'` son solo demostrativos. Más adelante los reemplazaremos con estado dinámico (`X`, `O`, `null`).

---

### 📦 Estructura de archivos sugerida

<Files
  items={[
    { type: "file", name: "package.json" },
    { type: "file", name: "tsconfig.json" },
    {
      type: "folder",
      name: "src",
      children: [
        { type: "file", name: "index.jsx" },
        { type: "file", name: "globals.css" },
        {
          type: "folder",
          name: "components",
          isOpen: true,
          children: [
            { type: "file", name: "Square.jsx" },
            { type: "file", name: "Board.tsx" },
          ],
        },
      ],
    },
    { type: "file", name: "next.config.js" },
    { type: "file", name: ".gitignore" },
    { type: "file", name: "extension.kt" },
  ]}
/>

## 📦 Lifting State Up con Zustand (React)

### 🎯 Objetivo

En esta sección vamos a **elevar el estado** del componente `Square` hacia su componente padre `Board`. Esto nos permitirá:

- Compartir el estado entre las 9 casillas del tablero.
- Controlar todo el estado del juego desde un solo lugar.
- Facilitar la verificación del ganador y alternancia de turnos.

### 🧠 ¿Por qué levantar el estado?

En React, es **mala práctica** que múltiples componentes hijos mantengan su propio estado si este necesita ser compartido o sincronizado. En el caso del juego `Tic Tac Toe`, cada casilla (`Square`) podría controlar su símbolo individual, pero entonces sería muy complejo:

- Verificar quién ganó.
- Resetear el juego.
- Coordinar turnos entre jugadores.

> ✅ La solución: levantar el estado al componente `Board`, y pasar valores y funciones a `Square` como _props_.

---

### 🧰 Configurando el estado global con Zustand

Creamos un **store global** con Zustand usando `combine` para definir el estado del juego.

```go:js
// store.js
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null) }, (set) => ({
    setSquares: (nextSquares) => {
      set((state) => ({
        squares:
          typeof nextSquares === 'function'
            ? nextSquares(state.squares)
            : nextSquares,
      }))
    },
  }))
)

export default useGameStore
```

> 🧩 `squares` es un array de 9 valores (`null`, `'X'`, `'O'`) que representa el tablero.

---

### 🧩 Componente `Board` con estado compartido

Ahora el componente `Board` será quien gestione el estado del tablero. Cuando una casilla es clickeada, `Board` actualizará su estado usando Zustand, y pasará el nuevo valor a cada `Square`.

```jsx
// Board.jsx
import useGameStore from "./store";
import Square from "./Square";

export default function Board() {
  const squares = useGameStore((state) => state.squares);
  const setSquares = useGameStore((state) => state.setSquares);

  function handleClick(i) {
    if (squares[i]) return; // no sobrescribas si ya hay un valor
    const nextSquares = squares.slice();
    nextSquares[i] = "X"; // por ahora solo jugamos con X
    setSquares(nextSquares);
  }

  return (
    <div
      style={{
        display: "grid",
        gridTemplateColumns: "repeat(3, 1fr)",
        gridTemplateRows: "repeat(3, 1fr)",
        width: "calc(3 * 2.5rem)",
        height: "calc(3 * 2.5rem)",
        border: "1px solid #999",
      }}
    >
      {squares.map((square, index) => (
        <Square
          key={index}
          value={square}
          onSquareClick={() => handleClick(index)}
        />
      ))}
    </div>
  );
}
```

---

### 🟦 Componente `Square` actualizado

Recibe el valor y la función `onSquareClick` desde `Board` como props.

```jsx
// Square.jsx
export default function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        padding: 0,
        backgroundColor: "#fff",
        border: "1px solid #999",
        outline: 0,
        borderRadius: 0,
        fontSize: "1rem",
        fontWeight: "bold",
        cursor: "pointer",
        width: "2.5rem",
        height: "2.5rem",
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  );
}
```

---

### 🔁 Resultado esperado del estado

El tablero se representa como un array así:

```go:js
const squares = ['O', null, 'X', 'X', 'X', 'O', 'O', null, null]
```

Cada `Square` recibe su valor directamente desde el array `squares`.

---

🔍 Nota técnica importante

```go:js
const nextSquares = squares.slice()
```

> Se crea una **copia inmutable** del array antes de modificarlo. Esto es esencial en React (y Zustand) para permitir actualizaciones seguras y evitar efectos colaterales.

### 📦 Estructura de archivos para el estado

<Files
  items={[
    { type: "file", name: "package.json" },
    { type: "file", name: "tsconfig.json" },
    {
      type: "folder",
      name: "src",
      children: [
        { type: "file", name: "index.jsx" },
        { type: "file", name: "globals.css" },
        {
          type: "folder",
          name: "components",
          isOpen: true,
          children: [
            { type: "file", name: "Square.jsx" },
            { type: "file", name: "Board.tsx" },
          ],
        },
        {
          type: "folder",
          name: "store",
          isOpen: true,
          children: [{ type: "file", name: "store.js" }],
        },
      ],
    },
    { type: "file", name: "next.config.js" },
    { type: "file", name: ".gitignore" },
    { type: "file", name: "extension.kt" },
  ]}
/>

## 🌀 Taking Turns (Alternancia de Turnos)

### 🎯 Objetivo

Solucionar un defecto importante: actualmente **solo el jugador 'X' puede jugar**. Para implementar la funcionalidad completa, debemos alternar los turnos entre `'X'` y `'O'` en cada clic.

### 🧠 Estrategia

Para alternar los turnos entre `'X'` y `'O'`:

- Usaremos un nuevo **estado booleano**: `xIsNext`.
- Inicialmente, `xIsNext` es `true`, lo que indica que `'X'` juega primero.
- Luego de cada movimiento, **invertimos** el valor de `xIsNext`.

### 🧰 Actualizar Zustand Store

Agregamos `xIsNext` al estado global de juego:

```go:js
// store.js
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null), xIsNext: true }, (set) => ({
    setSquares: (nextSquares) => {
      set((state) => ({
        squares:
          typeof nextSquares === 'function'
            ? nextSquares(state.squares)
            : nextSquares,
      }))
    },
    setXIsNext: (nextXIsNext) => {
      set((state) => ({
        xIsNext:
          typeof nextXIsNext === 'function'
            ? nextXIsNext(state.xIsNext)
            : nextXIsNext,
      }))
    },
  }))
)

export default useGameStore
```

> ✅ `xIsNext` indica de quién es el turno: `true` para `'X'`, `false` para `'O'`.

---

### 🔁 Alternar turnos en el componente `Board`

El componente `Board` ahora:

- Determina el jugador actual (`'X'` o `'O'`) según `xIsNext`.
- Al hacer clic en una casilla, actualiza el estado del tablero **y alterna el turno**.

```go:jsx
// Board.jsx
import useGameStore from './store'
import Square from './Square'

export default function Board() {
  const xIsNext = useGameStore((state) => state.xIsNext)
  const setXIsNext = useGameStore((state) => state.setXIsNext)
  const squares = useGameStore((state) => state.squares)
  const setSquares = useGameStore((state) => state.setSquares)

  const player = xIsNext ? 'X' : 'O'

  function handleClick(i) {
    if (squares[i]) return // No sobrescribas una casilla llena

    const nextSquares = squares.slice()
    nextSquares[i] = player

    setSquares(nextSquares)
    setXIsNext(!xIsNext) // Cambia el turno
  }

  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: 'repeat(3, 1fr)',
        width: 'calc(3 * 2.5rem)',
        height: 'calc(3 * 2.5rem)',
        border: '1px solid #999',
      }}
    >
      {squares.map((square, index) => (
        <Square
          key={index}
          value={square}
          onSquareClick={() => handleClick(index)}
        />
      ))}
    </div>
  )
}
```

### 🎮 Resultado

Ahora los jugadores pueden jugar de forma alterna:

- `'X'` siempre comienza.
- Después de cada clic, el turno cambia automáticamente a `'O'`, y luego de vuelta a `'X'`.

> 🧪 Ejemplo del estado del tablero después de 5 movimientos:

```go:js
['X', 'O', 'X', null, 'O', null, null, null, null]
```

Perfecto. Aquí tienes la sección **🧠 Declaring a Winner or Draw** perfectamente organizada en formato Markdown profesional, ideal para documentar un tutorial, blog o guía educativa:

---

### 🧠 Declaring a Winner or Draw (Declarando un ganador o empate)

### 🎯 Objetivo

Ahora que los jugadores pueden alternar turnos, es momento de **detectar cuándo el juego termina**:

- Cuando un jugador gana.
- Cuando se produce un empate (todas las casillas están ocupadas y no hay ganador).

### 🧩 Nuevas funciones auxiliares

Agregaremos tres funciones puras para calcular el estado del juego a partir del array de `squares`:

```js
// helpers.js
function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];

  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }

  return null;
}

function calculateTurns(squares) {
  return squares.filter((square) => !square).length;
}

function calculateStatus(winner, turns, player) {
  if (!winner && !turns) return "Draw";
  if (winner) return `Winner ${winner}`;
  return `Next player: ${player}`;
}
```

> ✅ Estas funciones son puras, reutilizables y facilitan separar lógica del UI.

---

### 🧠 Usar las funciones en el componente `Board`

Modificamos el componente `Board` para:

- Calcular al ganador con `calculateWinner`.
- Contar los turnos restantes con `calculateTurns`.
- Mostrar el estado del juego (ganador, empate o siguiente turno) usando `calculateStatus`.

```jsx
import useGameStore from "./store";
import Square from "./Square";
import { calculateWinner, calculateTurns, calculateStatus } from "./helpers";

export default function Board() {
  const xIsNext = useGameStore((state) => state.xIsNext);
  const setXIsNext = useGameStore((state) => state.setXIsNext);
  const squares = useGameStore((state) => state.squares);
  const setSquares = useGameStore((state) => state.setSquares);

  const winner = calculateWinner(squares);
  const turns = calculateTurns(squares);
  const player = xIsNext ? "X" : "O";
  const status = calculateStatus(winner, turns, player);

  function handleClick(i) {
    if (squares[i] || winner) return;

    const nextSquares = squares.slice();
    nextSquares[i] = player;

    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  return (
    <>
      <div style={{ marginBottom: "0.5rem" }}>{status}</div>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(3, 1fr)",
          gridTemplateRows: "repeat(3, 1fr)",
          width: "calc(3 * 2.5rem)",
          height: "calc(3 * 2.5rem)",
          border: "1px solid #999",
        }}
      >
        {squares.map((square, i) => (
          <Square key={i} value={square} onSquareClick={() => handleClick(i)} />
        ))}
      </div>
    </>
  );
}
```
