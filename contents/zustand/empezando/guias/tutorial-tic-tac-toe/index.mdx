---
title: Tic Tac Toe
description: En esta seccion Aprenderas a crear el juego de tic tac toe con zustand
---

## Construyendo un juego con React y Zustand

En este tutorial aprender√°s a crear un peque√±o juego de tres en l√≠nea (_tic-tac-toe_). Este tutorial asume que ya tienes conocimientos b√°sicos de React.

Las t√©cnicas que aprender√°s son fundamentales para construir cualquier aplicaci√≥n con React, y te dar√°n una comprensi√≥n m√°s profunda tanto de React como de Zustand al usarlos juntos.

Al finalizar, tendr√°s una aplicaci√≥n funcional que combina un estado global sencillo con una interfaz interactiva, ideal para entender c√≥mo manejar estados compartidos sin complicaciones.

## Estructura del tutorial

Este tutorial est√° dividido en varias secciones:

1. **Configuraci√≥n inicial**: Te dar√° un punto de partida para seguir el tutorial sin problemas.
2. **Introducci√≥n a React**: Aprender√°s los fundamentos de React: componentes, props y estado.
3. **Completar el juego**: Te ense√±ar√° las t√©cnicas m√°s comunes usadas en el desarrollo con React.
4. **A√±adir viaje en el tiempo**: Te dar√° una visi√≥n m√°s profunda sobre las ventajas √∫nicas que ofrece React.

## ¬øQue vas a construir?

En este tutorial, crear√°s un juego interactivo de **Tic-Tac-Toe (tres en l√≠nea)** utilizando **React y Zustand**. Al finalizar, tendr√°s:

- Un tablero interactivo.
- Manejo de turnos entre jugadores.
- Detecci√≥n autom√°tica de ganador.
- Historial de movimientos con opci√≥n de "viajar en el tiempo".

Puedes ver c√≥mo quedar√° al final aqu√≠:

### üß© Codigo completo del ejemplo

```go:tsx
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

// --- Zustand Store ---
const useGameStore = create(
  combine(
    {
      history: [Array(9).fill(null)],
      currentMove: 0,
    },
    (set, get) => ({
      setHistory: (nextHistory) => {
        set((state) => ({
          history:
            typeof nextHistory === 'function'
              ? nextHistory(state.history)
              : nextHistory,
        }))
      },
      setCurrentMove: (nextCurrentMove) => {
        set((state) => ({
          currentMove:
            typeof nextCurrentMove === 'function'
              ? nextCurrentMove(state.currentMove)
              : nextCurrentMove,
        }))
      },
    }),
  ),
)

// --- Componentes React ---

function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 0,
        backgroundColor: '#fff',
        border: '1px solid #999',
        outline: 0,
        borderRadius: 0,
        fontSize: '1rem',
        fontWeight: 'bold',
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  )
}

function Board({ xIsNext, squares, onPlay }) {
  const winner = calculateWinner(squares)
  const turns = calculateTurns(squares)
  const player = xIsNext ? 'X' : 'O'
  const status = calculateStatus(winner, turns, player)

  function handleClick(i) {
    if (squares[i] || winner) return
    const nextSquares = squares.slice()
    nextSquares[i] = player
    onPlay(nextSquares)
  }

  return (
    <>
      <div style={{ marginBottom: '0.5rem' }}>{status}</div>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          width: 'calc(3 * 2.5rem)',
          height: 'calc(3 * 2.5rem)',
          border: '1px solid #999',
        }}
      >
        {squares.map((_, i) => (
          <Square
            key={`square-${i}`}
            value={squares[i]}
            onSquareClick={() => handleClick(i)}
          />
        ))}
      </div>
    </>
  )
}

export default function Game() {
  const history = useGameStore((state) => state.history)
  const setHistory = useGameStore((state) => state.setHistory)
  const currentMove = useGameStore((state) => state.currentMove)
  const setCurrentMove = useGameStore((state) => state.setCurrentMove)
  const xIsNext = currentMove % 2 === 0
  const currentSquares = history[currentMove]

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]
    setHistory(nextHistory)
    setCurrentMove(nextHistory.length - 1)
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove)
  }

  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'row',
        fontFamily: 'monospace',
      }}
    >
      <div>
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div style={{ marginLeft: '1rem' }}>
        <ol>
          {history.map((_, historyIndex) => {
            const description =
              historyIndex > 0
                ? `Go to move #${historyIndex}`
                : 'Go to game start'

            return (
              <li key={historyIndex}>
                <button onClick={() => jumpTo(historyIndex)}>
                  {description}
                </button>
              </li>
            )
          })}
        </ol>
      </div>
    </div>
  )
}

// --- Funciones auxiliares ---

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ]

  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i]
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a]
    }
  }

  return null
}

function calculateTurns(squares) {
  return squares.filter((square) => !square).length
}

function calculateStatus(winner, turns, player) {
  if (!winner && !turns) return 'Draw'
  if (winner) return `Winner: ${winner}`
  return `Next player: ${player}`
}
```

Claro, aqu√≠ tienes tu explicaci√≥n y c√≥digo mejorado en **formato Markdown estructurado**, ideal para documentaci√≥n, tutoriales o un archivo `README.md`.

## üß± Building the Board - Tic Tac Toe con React

Vamos a construir el tablero para nuestro juego de Tic Tac Toe. Comenzaremos con un componente `Square`, que ser√° la unidad b√°sica del tablero, seguido por el componente `Board` que organizar√° estos cuadrados en una cuadr√≠cula 3x3.

### üéØ Objetivo

- Crear un componente **`Square`** que represente una casilla del juego.
- Crear un componente **`Board`** que contenga 9 `Square` en una cuadr√≠cula.

---

### üü© Componente `Square`

Este componente representa una sola casilla del tablero. Recibe dos props:

- `value`: el s√≠mbolo que se mostrar√° (`'X'`, `'O'`, o `null`).
- `onSquareClick`: funci√≥n que se ejecuta cuando se hace clic en la casilla.

```go:jsx
// Square.jsx
export default function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 0,
        backgroundColor: '#fff',
        border: '1px solid #999',
        outline: 0,
        borderRadius: 0,
        fontSize: '1rem',
        fontWeight: 'bold',
        cursor: 'pointer',
        width: '2.5rem',
        height: '2.5rem',
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  )
}
```

> üí° Este bot√≥n simula una celda cuadrada con dise√±o simple y responsivo.

---

### üß© Componente `Board`

El componente `Board` organiza 9 `Square` en una cuadr√≠cula 3x3. En esta etapa inicial, asignamos valores est√°ticos a cada cuadrado para mostrar c√≥mo se posicionan.

```go:jsx
// Board.jsx
import Square from './Square'

export default function Board() {
  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: 'repeat(3, 1fr)',
        width: 'calc(3 * 2.5rem)',
        height: 'calc(3 * 2.5rem)',
        border: '1px solid #999',
      }}
    >
      <Square value="1" onSquareClick={() => {}} />
      <Square value="2" onSquareClick={() => {}} />
      <Square value="3" onSquareClick={() => {}} />
      <Square value="4" onSquareClick={() => {}} />
      <Square value="5" onSquareClick={() => {}} />
      <Square value="6" onSquareClick={() => {}} />
      <Square value="7" onSquareClick={() => {}} />
      <Square value="8" onSquareClick={() => {}} />
      <Square value="9" onSquareClick={() => {}} />
    </div>
  )
}
```

> ‚ö†Ô∏è En este punto, los valores `'1'` a `'9'` son solo demostrativos. M√°s adelante los reemplazaremos con estado din√°mico (`X`, `O`, `null`).

---

### üì¶ Estructura de archivos sugerida

<Files
  items={[
    { type: "file", name: "package.json" },
    { type: "file", name: "tsconfig.json" },
    {
      type: "folder",
      name: "src",
      children: [
        { type: "file", name: "index.jsx" },
        { type: "file", name: "globals.css" },
        {
          type: "folder",
          name: "components",
          isOpen: true,
          children: [
            { type: "file", name: "Square.jsx" },
            { type: "file", name: "Board.tsx" },
          ],
        },
      ],
    },
    { type: "file", name: "next.config.js" },
    { type: "file", name: ".gitignore" },
    { type: "file", name: "extension.kt" },
  ]}
/>

## üì¶ Lifting State Up con Zustand (React)

### üéØ Objetivo

En esta secci√≥n vamos a **elevar el estado** del componente `Square` hacia su componente padre `Board`. Esto nos permitir√°:

- Compartir el estado entre las 9 casillas del tablero.
- Controlar todo el estado del juego desde un solo lugar.
- Facilitar la verificaci√≥n del ganador y alternancia de turnos.

### üß† ¬øPor qu√© levantar el estado?

En React, es **mala pr√°ctica** que m√∫ltiples componentes hijos mantengan su propio estado si este necesita ser compartido o sincronizado. En el caso del juego `Tic Tac Toe`, cada casilla (`Square`) podr√≠a controlar su s√≠mbolo individual, pero entonces ser√≠a muy complejo:

- Verificar qui√©n gan√≥.
- Resetear el juego.
- Coordinar turnos entre jugadores.

> ‚úÖ La soluci√≥n: levantar el estado al componente `Board`, y pasar valores y funciones a `Square` como _props_.

---

### üß∞ Configurando el estado global con Zustand

Creamos un **store global** con Zustand usando `combine` para definir el estado del juego.

```go:js
// store.js
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null) }, (set) => ({
    setSquares: (nextSquares) => {
      set((state) => ({
        squares:
          typeof nextSquares === 'function'
            ? nextSquares(state.squares)
            : nextSquares,
      }))
    },
  }))
)

export default useGameStore
```

> üß© `squares` es un array de 9 valores (`null`, `'X'`, `'O'`) que representa el tablero.

---

### üß© Componente `Board` con estado compartido

Ahora el componente `Board` ser√° quien gestione el estado del tablero. Cuando una casilla es clickeada, `Board` actualizar√° su estado usando Zustand, y pasar√° el nuevo valor a cada `Square`.

```jsx
// Board.jsx
import useGameStore from "./store";
import Square from "./Square";

export default function Board() {
  const squares = useGameStore((state) => state.squares);
  const setSquares = useGameStore((state) => state.setSquares);

  function handleClick(i) {
    if (squares[i]) return; // no sobrescribas si ya hay un valor
    const nextSquares = squares.slice();
    nextSquares[i] = "X"; // por ahora solo jugamos con X
    setSquares(nextSquares);
  }

  return (
    <div
      style={{
        display: "grid",
        gridTemplateColumns: "repeat(3, 1fr)",
        gridTemplateRows: "repeat(3, 1fr)",
        width: "calc(3 * 2.5rem)",
        height: "calc(3 * 2.5rem)",
        border: "1px solid #999",
      }}
    >
      {squares.map((square, index) => (
        <Square
          key={index}
          value={square}
          onSquareClick={() => handleClick(index)}
        />
      ))}
    </div>
  );
}
```

---

### üü¶ Componente `Square` actualizado

Recibe el valor y la funci√≥n `onSquareClick` desde `Board` como props.

```jsx
// Square.jsx
export default function Square({ value, onSquareClick }) {
  return (
    <button
      style={{
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        padding: 0,
        backgroundColor: "#fff",
        border: "1px solid #999",
        outline: 0,
        borderRadius: 0,
        fontSize: "1rem",
        fontWeight: "bold",
        cursor: "pointer",
        width: "2.5rem",
        height: "2.5rem",
      }}
      onClick={onSquareClick}
    >
      {value}
    </button>
  );
}
```

---

### üîÅ Resultado esperado del estado

El tablero se representa como un array as√≠:

```go:js
const squares = ['O', null, 'X', 'X', 'X', 'O', 'O', null, null]
```

Cada `Square` recibe su valor directamente desde el array `squares`.

---

üîç Nota t√©cnica importante

```go:js
const nextSquares = squares.slice()
```

> Se crea una **copia inmutable** del array antes de modificarlo. Esto es esencial en React (y Zustand) para permitir actualizaciones seguras y evitar efectos colaterales.

### üì¶ Estructura de archivos para el estado

<Files
  items={[
    { type: "file", name: "package.json" },
    { type: "file", name: "tsconfig.json" },
    {
      type: "folder",
      name: "src",
      children: [
        { type: "file", name: "index.jsx" },
        { type: "file", name: "globals.css" },
        {
          type: "folder",
          name: "components",
          isOpen: true,
          children: [
            { type: "file", name: "Square.jsx" },
            { type: "file", name: "Board.tsx" },
          ],
        },
        {
          type: "folder",
          name: "store",
          isOpen: true,
          children: [{ type: "file", name: "store.js" }],
        },
      ],
    },
    { type: "file", name: "next.config.js" },
    { type: "file", name: ".gitignore" },
    { type: "file", name: "extension.kt" },
  ]}
/>

## üåÄ Taking Turns (Alternancia de Turnos)

### üéØ Objetivo

Solucionar un defecto importante: actualmente **solo el jugador 'X' puede jugar**. Para implementar la funcionalidad completa, debemos alternar los turnos entre `'X'` y `'O'` en cada clic.

### üß† Estrategia

Para alternar los turnos entre `'X'` y `'O'`:

- Usaremos un nuevo **estado booleano**: `xIsNext`.
- Inicialmente, `xIsNext` es `true`, lo que indica que `'X'` juega primero.
- Luego de cada movimiento, **invertimos** el valor de `xIsNext`.

### üß∞ Actualizar Zustand Store

Agregamos `xIsNext` al estado global de juego:

```go:js
// store.js
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useGameStore = create(
  combine({ squares: Array(9).fill(null), xIsNext: true }, (set) => ({
    setSquares: (nextSquares) => {
      set((state) => ({
        squares:
          typeof nextSquares === 'function'
            ? nextSquares(state.squares)
            : nextSquares,
      }))
    },
    setXIsNext: (nextXIsNext) => {
      set((state) => ({
        xIsNext:
          typeof nextXIsNext === 'function'
            ? nextXIsNext(state.xIsNext)
            : nextXIsNext,
      }))
    },
  }))
)

export default useGameStore
```

> ‚úÖ `xIsNext` indica de qui√©n es el turno: `true` para `'X'`, `false` para `'O'`.

---

### üîÅ Alternar turnos en el componente `Board`

El componente `Board` ahora:

- Determina el jugador actual (`'X'` o `'O'`) seg√∫n `xIsNext`.
- Al hacer clic en una casilla, actualiza el estado del tablero **y alterna el turno**.

```go:jsx
// Board.jsx
import useGameStore from './store'
import Square from './Square'

export default function Board() {
  const xIsNext = useGameStore((state) => state.xIsNext)
  const setXIsNext = useGameStore((state) => state.setXIsNext)
  const squares = useGameStore((state) => state.squares)
  const setSquares = useGameStore((state) => state.setSquares)

  const player = xIsNext ? 'X' : 'O'

  function handleClick(i) {
    if (squares[i]) return // No sobrescribas una casilla llena

    const nextSquares = squares.slice()
    nextSquares[i] = player

    setSquares(nextSquares)
    setXIsNext(!xIsNext) // Cambia el turno
  }

  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: 'repeat(3, 1fr)',
        width: 'calc(3 * 2.5rem)',
        height: 'calc(3 * 2.5rem)',
        border: '1px solid #999',
      }}
    >
      {squares.map((square, index) => (
        <Square
          key={index}
          value={square}
          onSquareClick={() => handleClick(index)}
        />
      ))}
    </div>
  )
}
```

### üéÆ Resultado

Ahora los jugadores pueden jugar de forma alterna:

- `'X'` siempre comienza.
- Despu√©s de cada clic, el turno cambia autom√°ticamente a `'O'`, y luego de vuelta a `'X'`.

> üß™ Ejemplo del estado del tablero despu√©s de 5 movimientos:

```go:js
['X', 'O', 'X', null, 'O', null, null, null, null]
```

Perfecto. Aqu√≠ tienes la secci√≥n **üß† Declaring a Winner or Draw** perfectamente organizada en formato Markdown profesional, ideal para documentar un tutorial, blog o gu√≠a educativa:

---

### üß† Declaring a Winner or Draw (Declarando un ganador o empate)

### üéØ Objetivo

Ahora que los jugadores pueden alternar turnos, es momento de **detectar cu√°ndo el juego termina**:

- Cuando un jugador gana.
- Cuando se produce un empate (todas las casillas est√°n ocupadas y no hay ganador).

### üß© Nuevas funciones auxiliares

Agregaremos tres funciones puras para calcular el estado del juego a partir del array de `squares`:

```js
// helpers.js
function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];

  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }

  return null;
}

function calculateTurns(squares) {
  return squares.filter((square) => !square).length;
}

function calculateStatus(winner, turns, player) {
  if (!winner && !turns) return "Draw";
  if (winner) return `Winner ${winner}`;
  return `Next player: ${player}`;
}
```

> ‚úÖ Estas funciones son puras, reutilizables y facilitan separar l√≥gica del UI.

---

### üß† Usar las funciones en el componente `Board`

Modificamos el componente `Board` para:

- Calcular al ganador con `calculateWinner`.
- Contar los turnos restantes con `calculateTurns`.
- Mostrar el estado del juego (ganador, empate o siguiente turno) usando `calculateStatus`.

```jsx
import useGameStore from "./store";
import Square from "./Square";
import { calculateWinner, calculateTurns, calculateStatus } from "./helpers";

export default function Board() {
  const xIsNext = useGameStore((state) => state.xIsNext);
  const setXIsNext = useGameStore((state) => state.setXIsNext);
  const squares = useGameStore((state) => state.squares);
  const setSquares = useGameStore((state) => state.setSquares);

  const winner = calculateWinner(squares);
  const turns = calculateTurns(squares);
  const player = xIsNext ? "X" : "O";
  const status = calculateStatus(winner, turns, player);

  function handleClick(i) {
    if (squares[i] || winner) return;

    const nextSquares = squares.slice();
    nextSquares[i] = player;

    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  return (
    <>
      <div style={{ marginBottom: "0.5rem" }}>{status}</div>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(3, 1fr)",
          gridTemplateRows: "repeat(3, 1fr)",
          width: "calc(3 * 2.5rem)",
          height: "calc(3 * 2.5rem)",
          border: "1px solid #999",
        }}
      >
        {squares.map((square, i) => (
          <Square key={i} value={square} onSquareClick={() => handleClick(i)} />
        ))}
      </div>
    </>
  );
}
```
