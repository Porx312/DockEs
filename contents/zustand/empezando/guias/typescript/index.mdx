---
  title: Gu√≠a de Zustand con TypeScript
  description: Aprende a actualizar el estado global con Zustand utilizando actualizaciones planas y profundas con herramientas como Immer, optics-ts y Ramda.
---

# Gu√≠a de TypeScript con Zustand

## Uso basico

La principal diferencia al usar Zustand con **TypeScript** es que, en lugar de simplemente escribir `create(...)`, debes usar la sintaxis `create<T>()((set) => ...)`. Esta notaci√≥n incluye par√©ntesis adicionales y el uso expl√≠cito del tipo gen√©rico `T` para anotar el estado. Por ejemplo:

```go:ts
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))
```

---

<details>
  <summary>¬øPor qu√© no se puede inferir autom√°ticamente el tipo desde el estado inicial?</summary>
 > TL;DR: Porque el gen√©rico del estado (`T`) es **invariante**.

Cuando usas una funci√≥n como esta:

```go:ts
declare const create: <T>(f: (get: () => T) => T) => T
```

Y tratas de crear un store as√≠:

```go:ts
const x = create((get) => ({
  foo: 0,
  bar: () => get(),
}))
```

TypeScript **no puede inferir** el tipo de `x` correctamente. En su lugar, lo infiere como `unknown`. Esto sucede porque el par√°metro gen√©rico `T` aparece tanto como **entrada** (en `(get: () => T) => ...`) como **salida** (`=> T`). Eso lo hace invariante, y TypeScript no puede resolver este tipo sin ayuda expl√≠cita.

Un ejemplo m√°s simple ser√≠a:

```go:ts
const createFoo = {} as <T>(f: (t: T) => T) => T
const x = createFoo((_) => 'hello')
```

Aqu√≠ tambi√©n, `x` ser√° `unknown`, aunque esperar√≠amos `string`.

- Mas sobre la inferencia de tipos en TypeScript

Este problema ocurre porque **es imposible implementar** funciones cuyo tipo dependa de una invarianza como la mostrada. Para ilustrarlo:

```go:ts
const createFoo = (f) => f(/* ? */)
```

¬øC√≥mo le pasamos un valor a `f` si no sabemos qu√© tipo espera? Y sin llamar `f`, no podemos saber qu√© devuelve. Es un bucle l√≥gico imposible de resolver.

Esto aplica igualmente a `create` en Zustand. De hecho, Zustand **no puede implementar completamente** el tipo que promete. Aqu√≠ hay una prueba de ello:

```go:ts
const useBoundStore = create<{ foo: number }>()((_, get) => ({
  foo: get().foo, // Error en tiempo de ejecuci√≥n: Cannot read properties of undefined
}))
```

El c√≥digo compila, pero falla en tiempo de ejecuci√≥n porque `get()` a√∫n no tiene un estado definido. Zustand **hace una promesa que no puede cumplir**: `get()` siempre devuelve `T`, cuando en realidad inicialmente devuelve `undefined`.

En teor√≠a, podr√≠amos tipar `get` como `() => T | undefined`, pero eso ser√≠a inc√≥modo e incluso incorrecto, ya que eventualmente s√≠ devuelve `T`.

Lo ideal ser√≠a algo como:

```go:ts
(() => T) & WhenSync<(() => undefined)>
```

Pero esto no existe actualmente en TypeScript.

</details>

<details>
  <summary>¬øPor qu√© la sintaxis curried `create<T>()(...)`?</summary>
  
 
 TL;DR: Es una soluci√≥n para [microsoft/TypeScript#10571](https://github.com/microsoft/TypeScript/issues/10571)

Imagina esta situaci√≥n:

```go:ts
declare const withError: <T, E>(
  p: Promise<T>,
) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>
declare const doSomething: () => Promise<string>

const main = async () => {
  let [error, value] = await withError(doSomething())
}
```

Aqu√≠, `T` se infiere como `string`, pero `E` se infiere como `unknown`. Si queremos anotar `E` como `{ message: string }`, tenemos que especificar ambos tipos:

```go:ts
withError<string, { message: string }>(doSomething())
```

Esto es poco pr√°ctico. La soluci√≥n es usar una versi√≥n **currificada**:

```go:ts
declare const withError: {
  <E>(): <T>(
    p: Promise<T>,
  ) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>
  <T, E>(
    p: Promise<T>,
  ): Promise<[error: undefined, value: T] | [error: E, value: undefined]>
}
```

Ahora puedes hacer:

```go:ts
withError<{ message: string }>()(doSomething())
```

As√≠, `T` se sigue infiriendo y solo tienes que anotar `E`.

Zustand usa esta misma estrategia para permitirte anotar el tipo de estado (`T`) mientras dejas que otros tipos se infieran autom√°ticamente.

</details>

Si quieres evitar anotar manualmente los tipos, puedes usar el middleware `combine`, que permite **inferir el tipo del estado** autom√°ticamente:

```go:ts
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  })),
)
```

<details>
  <summary>Ten cuidado al usar `combine` con Zustand</summary>


Zustand permite **inferir autom√°ticamente el tipo del estado** cuando usas el middleware `combine`. Sin embargo, para lograrlo, se hace un peque√±o "truco" en los tipos de los par√°metros que recibes (`set`, `get`, etc.). Es importante entender c√≥mo funciona esto y cu√°ndo puede llevar a errores.

üß† ¬øQu√© significa eso de "mentir" en los tipos?

Cuando usas `combine`, el estado final no es solo el primer objeto que pasas, sino una **mezcla (shallow merge)** entre:

- El estado inicial (primer par√°metro)
- Y el objeto devuelto por la funci√≥n reductora (segundo par√°metro)

Por ejemplo:

```go:ts
create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
)
```

Aqu√≠:

- `{ bears: 0 }` es el estado inicial.
- La funci√≥n devuelve `{ increase: ... }`.

El estado completo es `{ bears: number, increase: (by: number) => void }`.

Sin embargo, dentro del callback, `get()` se tipa como `() => { bears: number }`, lo cual **no representa completamente** el estado real. Esto es una simplificaci√≥n que permite la inferencia autom√°tica de tipos.

‚ö†Ô∏è No es un error grave, pero s√≠ hay que tener cuidado

T√©cnicamente no es una "mentira", porque `{ bears: number }` es **subtipo** de `{ bears: number, increase: ... }`. En la mayor√≠a de los casos, esto no causa problemas.

Pero hay **algunas situaciones** donde puedes encontrarte con comportamientos inesperados:

1.  Usar `set(state, true)` con `replace: true`

Ejemplo:

```go:ts
set({ bears: 0 }, true)
```

Esto **reemplaza todo el estado**, incluyendo las acciones como `increase`. Aunque compila, **elimina parte del estado** y rompe la funcionalidad.

2. Usar `Object.keys(get())`

Si haces:

```go:ts
Object.keys(get()) // ["bears", "increase"]
```

Aunque el tipo sugiere que `get()` devuelve `{ bears: number }`, en realidad tambi√©n tiene `increase`. Puedes llevarte una sorpresa si no est√°s atento.

‚öñÔ∏è ¬øEs seguro usar `combine`?

S√≠, **en la mayor√≠a de los casos es completamente seguro y muy conveniente**, ya que evita tener que escribir manualmente la interfaz del estado. Pero debes conocer sus limitaciones y usarlo con criterio.

üí° Recomendaci√≥n: Usa `ExtractState` si necesitas el tipo fuera del store

Si quieres extraer el tipo del estado del store para usarlo en otros lugares, puedes usar el helper `ExtractState`:

```go:ts
import { create, ExtractState } from 'zustand'
import { combine } from 'zustand/middleware'

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
)

type BearState = ExtractState<typeof useBearStore>
```

Ahora puedes usar `BearState` para tipar otras funciones o componentes que trabajen con ese estado.

‚úÖ Cu√°ndo NO usar la versi√≥n currificada `create<T>()(...)`

No necesitas usar la sintaxis `create<T>()(...)` cuando usas middlewares como `combine` o `redux`, ya que **el estado se crea expl√≠citamente dentro del middleware** y TypeScript puede inferirlo correctamente.

Usa la forma directa:

```go:ts
create(combine(...))
```

En lugar de:

```go:ts
create<SomeState>()(combine(...)) // ‚ùå redundante con combine
```

</details>

# Usar middlewares

No necesitas hacer nada especial para usar middlewares con TypeScript.

```go:ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  devtools(
    persist(
      (set) => ({
        bears: 0,
        increase: (by) => set((state) => ({ bears: state.bears + by })),
      }),
      { name: 'bearStore' },
    ),
  ),
)
```

Solo aseg√∫rate de usar los middlewares directamente dentro de `create` para que la inferencia contextual funcione correctamente. Si encapsulas los middlewares en una funci√≥n como `myMiddlewares`, puede requerir tipos m√°s avanzados.

```go:ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

const myMiddlewares = (f) => devtools(persist(f, { name: 'bearStore' }))

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  myMiddlewares((set) => ({
    bears: 0,
    increase: (by) => set((state) => ({ bears: state.bears + by })),
  })),
)
```

Tambi√©n, recomendamos usar el middleware `devtools` al final. Por ejemplo, si usas `immer`, hazlo as√≠:

```go:ts
devtools(immer(...))
```

Y no as√≠:

```go:ts
immer(devtools(...))
```

Esto es porque `devtools` modifica `setState` y agrega un par√°metro `type`. Si otro middleware lo modifica antes, puedes perder esa informaci√≥n. Usarlo al final evita este problema.

# Crear middlewares y casos avanzados

Imagina que tienes que escribir un middleware como este:

```go:ts
import { create } from 'zustand'

const foo = (f, bar) => (set, get, store) => {
  store.foo = bar
  return f(set, get, store)
}

const useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))
console.log(useBearStore.foo.toUpperCase())
```

Zustand permite que los middlewares **muten el store**, pero ¬øc√≥mo se refleja esa mutaci√≥n a nivel de tipos? Es decir, ¬øc√≥mo tipar `foo` para que el c√≥digo compile?

En la mayor√≠a de los lenguajes est√°ticamente tipados, esto ser√≠a imposible. Pero gracias a TypeScript, Zustand ofrece algo llamado **"higher-kinded mutator"** que permite este tipo de mutaciones.

Si trabajas con middlewares complejos o usas el tipo `StateCreator`, debes entender este detalle. Puedes ver m√°s en [#710](https://github.com/pmndrs/zustand/pull/710).

---

# Manejar banderas `replace` din√°micas

Si el valor de `replace` se decide en tiempo de ejecuci√≥n (no es conocido en compilaci√≥n), puedes tener errores de tipo.

Soluci√≥n: Usa `Parameters<typeof setState>`

Ejemplo:

```go:ts
const replaceFlag = Math.random() > 0.5
const args = [{ bears: 5 }, replaceFlag] as Parameters<
  typeof useBearStore.setState
>
useBearStore.setState(...args)
```

Esto le dice a TypeScript que `args` tiene el mismo tipo que los par√°metros de `setState`.

Ejemplo completo:

```go:ts
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))

const replaceFlag = Math.random() > 0.5
const args = [{ bears: 5 }, replaceFlag] as Parameters<
  typeof useBearStore.setState
>
useBearStore.setState(...args)
```

# Recetas comunes para Zustand + TypeScript

## Middleware que **no cambia** el tipo del store

Ejemplo de un middleware `logger`:

```go:ts
import { create, StateCreator, StoreMutatorIdentifier } from 'zustand'

type Logger = <
  T,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = [],
>(
  f: StateCreator<T, Mps, Mcs>,
  name?: string,
) => StateCreator<T, Mps, Mcs>

const logger = <T>(
  f: StateCreator<T, [], []>,
  name?: string,
): StateCreator<T, [], []> => (set, get, store) => {
  const loggedSet: typeof set = (...a) => {
    set(...a)
    console.log(...(name ? [`${name}:`] : []), get())
  }

  const setState = store.setState
  store.setState = (...a) => {
    setState(...a)
    console.log(...(name ? [`${name}:`] : []), store.getState())
  }

  return f(loggedSet, get, store)
}

export { logger }
```

Uso:

```go:ts
const useBearStore = create<BearState>()(
  logger((set) => ({
    bears: 0,
    increase: (by) => set((state) => ({ bears: state.bears + by })),
  })),
  'bear-store',
)
```

---

## Middleware que **cambia** el tipo del store

Ejemplo de un middleware `foo` que agrega una propiedad al store:

```go:ts
import {
  create,
  StateCreator,
  StoreMutatorIdentifier,
  Mutate,
  StoreApi,
} from 'zustand'

declare module 'zustand' {
  interface StoreMutators<S, A> {
    foo: { foo: A }
  }
}

type Foo = <
  T,
  A,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = [],
>(
  f: StateCreator<T, [...Mps, ['foo', A]], Mcs>,
  bar: A,
) => StateCreator<T, Mps, [['foo', A], ...Mcs]>
)

const foo = <T, A>(
  f: StateCreator<T, [], []>,
  bar: A,
): StateCreator<T, [], []> => (set, get, _store) => {
  const store = _store as Mutate<StoreApi<T>, [['foo', A]]>
  store.foo = bar
  return f(set, get, _store)
}

export { foo }
```

Uso:

```go:ts
const useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))
console.log(useBearStore.foo.toUpperCase()) // funciona ‚úÖ
```

---

## `create` sin la sintaxis currificada

Si no quieres usar `create<T>()(...)`, puedes pasar los tipos directamente:

```go:ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<
  BearState,
  [
    ['zustand/persist', BearState],
    ['zustand/devtools', never]
  ]
>(devtools(persist((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}), { name: 'bearStore' })))
```

‚ö†Ô∏è Nota: Esto act√∫a m√°s como una **afirmaci√≥n de tipo** que como una anotaci√≥n real. No recomendado a menos que sea necesario.

---

## Patron de slices

Divide tu store en partes reutilizables:

```go:ts
import { create, StateCreator } from 'zustand'

interface BearSlice {
  bears: number
  addBear: () => void
  eatFish: () => void
}

interface FishSlice {
  fishes: number
  addFish: () => void
}

interface SharedSlice {
  addBoth: () => void
  getBoth: () => number
}

const createBearSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  BearSlice
> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
})

const createFishSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  FishSlice
> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
})

const createSharedSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  SharedSlice
> = (set, get) => ({
  addBoth: () => {
    get().addBear()
    get().addFish()
  },
  getBoth: () => get().bears + get().fishes,
})

const useBoundStore = create<BearSlice & FishSlice & SharedSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
  ...createSharedSlice(...a),
}))
```

---

## Hook `useStore` tipado para stores "vanilla"

Para usar Zustand con `createStore` y tener un hook personalizado:

```go:ts
import { useStore } from 'zustand'
import { createStore } from 'zustand/vanilla'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const bearStore = createStore<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))

function useBearStore(): BearState
function useBearStore<T>(selector: (state: BearState) => T): T
function useBearStore<T>(selector?: (state: BearState) => T) {
  return useStore(bearStore, selector!)
}
```

## Funcion generica para crear hooks tipados

Evita repetir c√≥digo si usas varios stores vanilla:

```go:ts
import { useStore, StoreApi } from 'zustand'
import { createStore } from 'zustand/vanilla'

const createBoundedUseStore = ((store) => (selector) =>
  useStore(store, selector)) as <S extends StoreApi<unknown>>(
  store: S,
) => {
  (): ExtractState<S>
  <T>(selector: (state: ExtractState<S>) => T): T
}

type ExtractState<S> = S extends { getState: () => infer X } ? X : never

// Uso
const bearStore = createStore<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))

const useBearStore = createBoundedUseStore(bearStore)
```

---

## Referencia de middlewares y sus mutadores

| Middleware              | Mutador                                    |
| ----------------------- | ------------------------------------------ |
| `devtools`              | `['zustand/devtools', never]`              |
| `persist`               | `['zustand/persist', YourPersistedState]`  |
| `immer`                 | `['zustand/immer', never]`                 |
| `subscribeWithSelector` | `['zustand/subscribeWithSelector', never]` |
| `redux`                 | `['zustand/redux', YourAction]`            |
| `combine`               | Sin mutador (no modifica el store)         |

üëâ `YourPersistedState` es el tipo del estado guardado. Si usas `partialize`, debe ser su retorno. Si no, usa `Partial<State>` o `unknown`.
