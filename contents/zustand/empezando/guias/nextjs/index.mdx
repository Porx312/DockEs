---
title: nextjs
description: Aprende cÃ³mo actualizar el estado global con Zustand usando actualizaciones planas y profundas, con herramientas como Immer, optics-ts y Ramda.
---

## CÃ³mo actualizar el estado correctamente en Zustand (Flat & Nested Updates)

Zustand es una librerÃ­a minimalista y poderosa para manejar estado global en aplicaciones React. Aunque su API es muy simple, al trabajar con objetos anidados puede que te preguntes: Â¿cÃ³mo actualizo mi estado correctamente?

Este artÃ­culo cubre:

- ğŸ”„ Actualizaciones planas (flat updates)
- ğŸ§© Actualizaciones de objetos profundamente anidados (deep nested updates)
- ğŸ› ï¸ Alternativas: Immer, optics-ts, Ramda

---

## âœ… ActualizaciÃ³n de estado: Lo bÃ¡sico (Flat Updates)

Zustand provee una funciÃ³n `set` para modificar el estado global. Cuando trabajas con propiedades simples (no anidadas), actualizar es directo:

### ğŸ“¦ Ejemplo:

```go:ts
import { create } from 'zustand'

type State = {
  firstName: string
  lastName: string
}

type Actions = {
  updateFirstName: (firstName: string) => void
  updateLastName: (lastName: string) => void
}

const usePersonStore = create<State & Actions>((set) => ({
  firstName: '',
  lastName: '',
  updateFirstName: (firstName) => set({ firstName }),
  updateLastName: (lastName) => set({ lastName }),
}))
```

### ğŸ’¡ Uso en React:

```go:tsx
function App() {
  const firstName = usePersonStore((s) => s.firstName)
  const updateFirstName = usePersonStore((s) => s.updateFirstName)

  return (
    <label>
      First name:
      <input
        value={firstName}
        onChange={(e) => updateFirstName(e.target.value)}
      />
    </label>
  )
}
```

Zustand hace **shallow merge** automÃ¡ticamente, asÃ­ que puedes modificar solo una parte del estado sin perder lo demÃ¡s.

---

## ğŸ§© Actualizando estado anidado

Cuando el estado es un objeto profundamente anidado, la actualizaciÃ³n se complica.

### ğŸ¯ Estado de ejemplo:

```go:ts
type State = {
  deep: {
    nested: {
      obj: {
        count: number
      }
    }
  }
}
```

### âŒ Enfoque tradicional (spread manual):

```go:ts
normalInc: () =>
  set((state) => ({
    deep: {
      ...state.deep,
      nested: {
        ...state.deep.nested,
        obj: {
          ...state.deep.nested.obj,
          count: state.deep.nested.obj.count + 1
        }
      }
    }
  })),
```

ğŸ”» Es verboso, propenso a errores y difÃ­cil de escalar.

---

## ğŸ› ï¸ Alternativas modernas para actualizar objetos anidados

### âœ… 1. **Immer**

[Immer](https://immerjs.github.io/immer/) permite mutar el estado de forma _inmutable_, usando sintaxis mutable:

```go:ts
import { produce } from 'immer'

immerInc: () =>
  set(produce((state: State) => {
    state.deep.nested.obj.count++
  })),
```

âœ”ï¸ Legible, limpio y fÃ¡cil de mantener.

---

### âœ… 2. **optics-ts**

[`optics-ts`](https://github.com/akheron/optics-ts) permite navegar objetos con _Ã³pticas_:

```go:ts
import * as O from "optics-ts"

opticsInc: () =>
  set(
    O.modify(
      O.optic<State>().path("deep", "nested", "obj", "count")
    )((c) => c + 1)
  ),
```

âœ”ï¸ Funciona bien con TypeScript y evita mutaciÃ³n o proxies.

---

### âœ… 3. **Ramda**

[Ramda](https://ramdajs.com/) tiene una funciÃ³n `modifyPath`:

```go:ts
import * as R from "ramda"

ramdaInc: () =>
  set(
    R.modifyPath(["deep", "nested", "obj", "count"], (c: number) => c + 1)
  ),
```

âœ”ï¸ Declarativo y funcional. Bueno si ya usas Ramda.

---

## ğŸ§ª ComparaciÃ³n visual de alternativas

| MÃ©todo        | Ventajas               | Desventajas                   |
| ------------- | ---------------------- | ----------------------------- |
| Spread manual | Sin dependencias       | Verboso, difÃ­cil de mantener  |
| **Immer**     | Legible, mutable-style | Usa proxies (a veces confuso) |
| **optics-ts** | Typesafe, declarativo  | Nueva curva de aprendizaje    |
| **Ramda**     | Funcional y limpio     | Necesita librerÃ­a externa     |

---

## ğŸ§¬ ConclusiÃ³n

- Para **estado plano**, Zustand es directo y eficiente.
- Para **estado anidado**, usa herramientas como **Immer**, **optics-ts** o **Ramda**.
- Elige la alternativa que mÃ¡s se adapte a tu equipo o estilo de cÃ³digo.

---

### ğŸ§ª Demo prÃ¡ctica

Puedes ver todo esto funcionando aquÃ­:
ğŸ‘‰ [Zustand + Immer + Optics + Ramda â€” Demo en CodeSandbox](https://codesandbox.io/s/zustand-normal-immer-optics-ramda-updating-ynn3o)
