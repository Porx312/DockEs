---
title: TypeScript para Programadores de JavaScript
description: Una introducci√≥n pr√°ctica a TypeScript para desarrolladores familiarizados con JavaScript. Aprende c√≥mo TypeScript ampl√≠a el lenguaje JavaScript con tipado est√°tico, inferencia de tipos, interfaces, gen√©ricos y un sistema de tipos estructural, todo sin abandonar tus conocimientos actuales.
---

TypeScript guarda una relaci√≥n inusual con JavaScript. TypeScript ofrece todas las caracter√≠sticas del lenguaje JavaScript y agrega una **capa adicional de verificaci√≥n de tipos**.

Por ejemplo, JavaScript proporciona tipos primitivos como `string` y `number`, pero no verifica que los uses de forma consistente. TypeScript s√≠ lo hace.

Esto significa que tu c√≥digo JavaScript ya funcional tambi√©n es un c√≥digo v√°lido en TypeScript. El **principal beneficio de TypeScript** es que puede detectar comportamientos inesperados en tu c√≥digo, reduciendo las probabilidades de errores.

Esta gu√≠a ofrece una visi√≥n general del sistema de tipos de TypeScript.

---

## Inferencia de Tipos

TypeScript entiende c√≥mo funciona JavaScript y puede **inferir tipos autom√°ticamente** en muchos casos.

```go:ts
let helloWorld = "Hola Mundo";
// Se infiere como: let helloWorld: string
```

Gracias a su conocimiento del lenguaje, TypeScript puede deducir tipos sin que tengas que escribir anotaciones adicionales. As√≠ sabe que `helloWorld` es un `string`.

Si has usado Visual Studio Code, es probable que hayas visto autocompletado y ayuda contextual: eso es posible gracias a TypeScript funcionando en segundo plano.

---

## Definicion de Tipos

En JavaScript puedes usar muchos patrones de dise√±o, aunque algunos dificultan la inferencia autom√°tica de tipos. Para esos casos, TypeScript te permite **declarar expl√≠citamente los tipos** que deber√≠an usarse.

```go:ts
const user = {
  name: "Hayes",
  id: 0,
};
```

Puedes describir la forma del objeto con una `interface`:

```go:ts
interface Usuario {
  name: string;
  id: number;
}

const user: Usuario = {
  name: "Hayes",
  id: 0,
};
```

Si el objeto no coincide con la interfaz, TypeScript mostrar√° un error:

```go:ts
const user: Usuario = {
  username: "Hayes", // ‚ùå Error: propiedad no reconocida
  id: 0,
};
```

---

## Clases y Programacion Orientada a Objetos

TypeScript tambi√©n admite clases e interfaces de forma similar a JavaScript moderno:

```go:ts
interface Usuario {
  name: string;
  id: number;
}

class CuentaUsuario {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: Usuario = new CuentaUsuario("Murphy", 1);
```

Tambi√©n puedes usar interfaces para anotar par√°metros y valores de retorno de funciones:

```go:ts
function eliminarUsuario(user: Usuario) { /* ... */ }

function obtenerAdmin(): Usuario {
  // ...
}
```

---

## Tipos Primitivos

Adem√°s de los tipos est√°ndar de JavaScript (`boolean`, `number`, `string`, etc.), TypeScript a√±ade:

- `any`: cualquier tipo (sin restricciones)
- `unknown`: tipo desconocido que requiere verificaci√≥n
- `never`: representa un valor que nunca ocurre
- `void`: funciones que no devuelven valor

---

## Interfaces vs Tipos (`type`)

Puedes crear tipos personalizados de dos maneras:

- `interface`: para describir formas de objetos (preferido)
- `type`: √∫til cuando necesitas uniones, intersecciones o alias complejos

---

## Composicion de Tipos

### üîÄ Uniones (`|`)

Puedes declarar que un valor puede ser uno de varios tipos:

```go:ts
type EstadoVentana = "abierta" | "cerrada" | "minimizada";

function obtenerLongitud(obj: string | string[]) {
  return obj.length;
}
```

### üîç Comprobaci√≥n de Tipo en Tiempo de Ejecuci√≥n

Usa `typeof` o `Array.isArray` para distinguir tipos:

| Tipo   | Predicado                   |
| ------ | --------------------------- |
| string | `typeof valor === "string"` |
| number | `typeof valor === "number"` |
| array  | `Array.isArray(valor)`      |

```go:ts
function envolverEnArray(obj: string | string[]) {
  if (typeof obj === "string") {
    return [obj];
  }
  return obj;
}
```

---

## Genericos

Los gen√©ricos permiten definir tipos reutilizables:

```go:ts
type ArrayDeStrings = Array<string>;

interface Mochila<Tipo> {
  agregar: (obj: Tipo) => void;
  obtener: () => Tipo;
}

declare const mochila: Mochila<string>;

const objeto = mochila.obtener();
mochila.agregar(23); // ‚ùå Error: se esperaba string
```

---

## Sistema de Tipado Estructural

Uno de los principios clave de TypeScript es que **compara tipos por su forma** y no por su nombre o jerarqu√≠a.

```go:ts
interface Punto {
  x: number;
  y: number;
}

function mostrarPunto(p: Punto) {
  console.log(`${p.x}, ${p.y}`);
}

const punto = { x: 12, y: 26 };
mostrarPunto(punto); // ‚úÖ OK

const puntoExtra = { x: 12, y: 26, z: 100 };
mostrarPunto(puntoExtra); // ‚úÖ OK: tiene forma compatible

const color = { hex: "#0000FF" };
mostrarPunto(color); // ‚ùå Error: faltan x e y
```

Esto tambi√©n aplica a clases:

```go:ts
class PuntoVirtual {
  constructor(public x: number, public y: number) {}
}

const nuevoPunto = new PuntoVirtual(10, 50);
mostrarPunto(nuevoPunto); // ‚úÖ OK
```
