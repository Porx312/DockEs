---
title: Gu√≠a completa de clases en TypeScript
description: Explora c√≥mo funcionan las clases en TypeScript, desde la definici√≥n b√°sica de clases y herencia, hasta temas avanzados como el uso de this como tipo, clases abstractas, propiedades de par√°metros, expresiones de clase y relaciones estructurales entre clases. Aprende a escribir clases m√°s seguras y reutilizables, aprovechando al m√°ximo el sistema de tipos de TypeScript.
---

> **Lectura recomendada:**
> [Clases (MDN)](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Classes)
> [Constructor (MDN)](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Classes/constructor)
> [Extends (MDN)](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Classes/extends)

TypeScript ofrece compatibilidad total con la palabra clave `class` introducida en ES2015. Adem√°s de las funcionalidades est√°ndar de JavaScript, TypeScript permite agregar **anotaciones de tipo**, asegurando un desarrollo m√°s robusto.

---

## üìå Miembros de Clase

### Campos (`fields`)

Un campo crea una propiedad p√∫blica y modificable en la clase:

```go:ts
class Point {
  x: number;
  y: number;
}

const pt = new Point();
pt.x = 0;
pt.y = 0;
```

Tambi√©n puedes inicializar campos directamente:

```go:ts
class Point {
  x = 0;
  y = 0;
}
```

El tipo se infiere autom√°ticamente a partir del valor:

```go:ts
pt.x = "0"; // ‚ùå Error: 'string' no es asignable a 'number'
```

### `strictPropertyInitialization`

Si esta opci√≥n est√° activada, TypeScript obliga a inicializar todos los campos en el constructor:

```go:ts
class BadGreeter {
  name: string; // ‚ùå Error: no est√° inicializado
}
```

Soluci√≥n:

```go:ts
class GoodGreeter {
  name: string;

  constructor() {
    this.name = "Hola";
  }
}
```

Tambi√©n puedes usar el **operador de aserci√≥n de asignaci√≥n definitiva** (`!`):

```go:ts
class OKGreeter {
  name!: string; // ‚úÖ No error aunque no est√© inicializado
}
```

---

## üîí Propiedades `readonly`

Las propiedades marcadas como `readonly` no pueden ser modificadas fuera del constructor:

```go:ts
class Greeter {
  readonly name: string = "mundo";

  constructor(otherName?: string) {
    if (otherName !== undefined) {
      this.name = otherName;
    }
  }

  err() {
    this.name = "no permitido"; // ‚ùå Error
  }
}
```

---

## üß± Constructores

Puedes a√±adir par√°metros con tipos, valores por defecto u **overloads**:

```go:ts
class Point {
  x: number;
  y: number;

  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
}
```

Tambi√©n puedes definir m√∫ltiples firmas:

```go:ts
class Point {
  constructor(x: number, y: number);
  constructor(xy: string);
  constructor(x: string | number, y: number = 0) {
    // l√≥gica
  }
}
```

> Los constructores no pueden tener tipo de retorno, y los gen√©ricos se definen en la clase, no en el constructor.

---

## üß¨ Herencia y `super()`

Cuando heredas de otra clase, debes llamar a `super()` antes de acceder a `this`:

```go:ts
class Base {
  k = 4;
}

class Derived extends Base {
  constructor() {
    super(); // Obligatorio antes de usar this
    console.log(this.k);
  }
}
```

---

## ‚öô Metodos

Los m√©todos son funciones dentro de una clase. Usan las mismas anotaciones de tipo que las funciones normales:

```go:ts
class Point {
  x = 10;
  y = 10;

  scale(n: number): void {
    this.x *= n;
    this.y *= n;
  }
}
```

> Siempre accede a propiedades de la clase con `this.` dentro de m√©todos.

---

## ü™ü Getters y Setters

```go:ts
class C {
  _length = 0;

  get length() {
    return this._length;
  }

  set length(value) {
    this._length = value;
  }
}
```

TypeScript infiere tipos autom√°ticamente. Si no defines un `set`, la propiedad se considera `readonly`.

Desde TypeScript 4.3 puedes tener tipos distintos en `get` y `set`:

```go:ts
class Thing {
  _size = 0;

  get size(): number {
    return this._size;
  }

  set size(value: string | number | boolean) {
    const num = Number(value);
    this._size = Number.isFinite(num) ? num : 0;
  }
}
```

---

## üìá √çndices con firma (`index signatures`)

```go:ts
class MyClass {
  [key: string]: boolean | ((s: string) => boolean);

  check(s: string) {
    return this[s] as boolean;
  }
}
```

> No es recomendable guardar datos indexados directamente en la instancia; mejor usar un objeto separado.

---

## ‚úÖ Implementar Interfaces (`implements`)

```go:ts
interface Pingable {
  ping(): void;
}

class Sonar implements Pingable {
  ping() {
    console.log("ping!");
  }
}

class Ball implements Pingable {
  pong() {
    console.log("pong!");
  }
}
// ‚ùå Error: falta el m√©todo 'ping'
```

> `implements` solo valida tipos; **no modifica el comportamiento** ni a√±ade propiedades autom√°ticamente.

---

## üß¨ Herencia (`extends`)

```go:ts
class Animal {
  move() {
    console.log("¬°Me estoy moviendo!");
  }
}

class Dog extends Animal {
  woof(times: number) {
    console.log("woof!".repeat(times));
  }
}
```

---

## üîÅ Sobrescribir Metodos

Puedes sobrescribir m√©todos del padre:

```go:ts
class Base {
  greet() {
    console.log("Hola mundo!");
  }
}

class Derived extends Base {
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(`Hola, ${name.toUpperCase()}`);
    }
  }
}
```

> Debes mantener la compatibilidad con la firma del m√©todo base. Si cambias el n√∫mero o tipo de par√°metros, TypeScript mostrar√° un error.

---

## üéØ Declaraciones solo de tipo (`declare`)

Para redefinir solo el tipo de una propiedad heredada sin afectar la ejecuci√≥n:

```go:ts
class AnimalHouse {
  resident: Animal;
  constructor(animal: Animal) {
    this.resident = animal;
  }
}

class DogHouse extends AnimalHouse {
  declare resident: Dog; // Solo afecta el tipo
  constructor(dog: Dog) {
    super(dog);
  }
}
```

---

## üîÑ Orden de Inicializaci√≥n

```go:ts
class Base {
  name = "base";
  constructor() {
    console.log("Mi nombre es " + this.name);
  }
}

class Derived extends Base {
  name = "derived";
}

const d = new Derived(); // Imprime "base"
```

> El orden es:

1. Inicializaci√≥n de campos del padre
2. Constructor del padre
3. Inicializaci√≥n de campos del hijo
4. Constructor del hijo

---

## ‚ö†Ô∏è Heredar Tipos Integrados (como `Error`, `Array`)

Heredar de tipos integrados requiere configuraci√≥n especial:

```go:ts
class MsgError extends Error {
  constructor(m: string) {
    super(m);
    Object.setPrototypeOf(this, MsgError.prototype);
  }

  sayHello() {
    return "hola " + this.message;
  }
}
```

> Sin esta l√≠nea `Object.setPrototypeOf(...)`, `instanceof` puede fallar y m√©todos como `sayHello` no estar√°n disponibles.

---

## Visibilidad de Miembros en TypeScript

### `public`

Por defecto, todos los miembros de una clase en TypeScript son p√∫blicos (`public`). Esto significa que pueden ser accedidos desde cualquier parte:

```go:ts
class Greeter {
  public greet() {
    console.log("¬°Hola!");
  }
}

const g = new Greeter();
g.greet(); // OK
```

> Aunque no es necesario escribir `public`, puedes usarlo por razones de estilo o legibilidad.

---

### `protected`

Los miembros `protected` **solo son accesibles desde la clase base y sus subclases**.

```go:ts
class Greeter {
  public greet() {
    console.log("Hola, " + this.getName());
  }

  protected getName() {
    return "mundo";
  }
}

class SpecialGreeter extends Greeter {
  public howdy() {
    console.log("¬°Qu√© tal, " + this.getName() + "!");
  }
}
```

```go:ts
const g = new SpecialGreeter();
g.greet(); // OK
g.getName(); // ‚ùå Error: 'getName' es 'protected'
```

#### Exponer miembros protegidos

Una subclase puede optar por hacer p√∫blico un miembro `protected` (aunque debe hacerse con cuidado):

```go:ts
class Base {
  protected m = 10;
}

class Derived extends Base {
  m = 15; // Ahora es p√∫blico por omisi√≥n
}

const d = new Derived();
console.log(d.m); // OK
```

> Si no deseas exponerlo p√∫blicamente, recuerda declarar expl√≠citamente `protected` en la subclase.

#### Acceso cruzado entre subclases

No se permite acceder a miembros `protected` desde instancias de otras subclases:

```go:ts
class Base {
  protected x = 1;
}

class Derived1 extends Base {
  protected x = 5;
}

class Derived2 extends Base {
  f1(other: Derived2) {
    other.x = 10; // OK
  }

  f2(other: Derived1) {
    other.x = 10; // ‚ùå Error
  }
}
```

---

### `private`

Los miembros `private` **solo son accesibles desde dentro de la clase en que fueron definidos**. Ni siquiera las subclases pueden acceder a ellos.

```go:ts
class Base {
  private x = 0;
}

const b = new Base();
console.log(b.x); // ‚ùå Error
```

```go:ts
class Derived extends Base {
  showX() {
    console.log(this.x); // ‚ùå Error
  }
}
```

> Adem√°s, no puedes redefinir un miembro `private` como `public` en una subclase.

#### Acceso entre instancias

A diferencia de algunos lenguajes, TypeScript **s√≠ permite que diferentes instancias de una clase accedan a miembros privados entre s√≠**:

```go:ts
class A {
  private x = 10;

  sameAs(other: A) {
    return this.x === other.x; // OK
  }
}
```

---

### Consideraciones sobre privacidad

Las restricciones de `private` y `protected` **son solo verificaciones de tipo**. A nivel de ejecuci√≥n (JavaScript), a√∫n puedes acceder a estos miembros:

```go:ts
class MySafe {
  private secretKey = 12345;
}

const s = new MySafe();
console.log(s["secretKey"]); // ‚ö†Ô∏è Funciona, aunque no deber√≠a
```

#### Campos privados "duros" con

TypeScript tambi√©n admite la sintaxis de campos privados reales de JavaScript:

```go:ts
class Dog {
  #barkAmount = 0;
  personality = "feliz";

  constructor() {}
}
```

> Estos campos son verdaderamente privados y no pueden ser accedidos de ninguna forma externa.

---

## Miembros Estaticos

Los miembros `static` **pertenecen a la clase en s√≠, no a las instancias**:

```go:ts
class MyClass {
  static x = 0;

  static printX() {
    console.log(MyClass.x);
  }
}

MyClass.printX(); // OK
```

Pueden tener modificadores de visibilidad como `private`:

```go:ts
class MyClass {
  private static x = 0;
}

console.log(MyClass.x); // ‚ùå Error
```

Tambi√©n se heredan:

```go:ts
class Base {
  static getGreeting() {
    return "Hola mundo";
  }
}

class Derived extends Base {
  myGreeting = Derived.getGreeting(); // OK
}
```

#### Nombres estaticos reservados

No puedes usar nombres como `name`, `length`, o `call` como miembros est√°ticos, ya que entrar√≠an en conflicto con propiedades del prototipo de `Function`.

---

### Clases "estaticas"

JavaScript/TypeScript no tienen clases `static` como C#, porque en JS se pueden usar objetos simples o funciones:

```go:ts
// No recomendado
class MyStaticClass {
  static doSomething() {}
}

// Alternativas m√°s limpias
function doSomething() {}

const Utils = {
  doSomething() {},
};
```

---

### Bloques estaticos

Puedes usar bloques `static` para inicializar miembros privados u otros procesos complejos en la clase:

```go:ts
class Foo {
  static #count = 0;

  get count() {
    return Foo.#count;
  }

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    } catch {}
  }
}
```

---

## Clases Genericas

Al igual que las interfaces, las clases pueden ser gen√©ricas:

```go:ts
class Box<Type> {
  contents: Type;
  constructor(value: Type) {
    this.contents = value;
  }
}

const b = new Box("hola"); // Box<string>
```

> Las clases gen√©ricas pueden tener restricciones (`extends`) y valores por defecto.

#### Miembros estaticos y tipos gen√©ricos

No puedes usar el tipo gen√©rico en miembros est√°ticos:

```go:ts
class Box<Type> {
  static defaultValue: Type; // ‚ùå Error
}
```

Esto es porque **los tipos se borran en tiempo de ejecuci√≥n**, y `Box.defaultValue` ser√≠a compartido entre todas las instancias del tipo.

---

## `this` en tiempo de ejecucion

JavaScript tiene un comportamiento peculiar con `this`. Su valor depende de **c√≥mo se llama una funci√≥n**, no de d√≥nde se defini√≥.

```go:ts
class MyClass {
  name = "MiClase";

  getName() {
    return this.name;
  }
}

const c = new MyClass();
const obj = {
  name: "objeto",
  getName: c.getName,
};

console.log(obj.getName()); // "objeto"
```

> Se pierde el contexto original. Esto puede evitarse usando **funciones flecha** o **par√°metros `this`**.

---

### Funciones flecha

```go:ts
class MyClass {
  name = "MiClase";
  getName = () => this.name;
}

const c = new MyClass();
const g = c.getName;
console.log(g()); // "MiClase"
```

> ‚úÖ No pierde el contexto.
> ‚ö†Ô∏è Cada instancia tiene su propia copia ‚Üí mayor uso de memoria.
> ‚ùå No puedes usar `super`.

---

### Parametro `this`

```go:ts
class MyClass {
  name = "MiClase";

  getName(this: MyClass) {
    return this.name;
  }
}

const c = new MyClass();
c.getName(); // OK

const g = c.getName;
console.log(g()); // ‚ùå Error en tiempo de compilaci√≥n
```

> ‚úÖ Se ahorra memoria, solo una funci√≥n compartida.
> ‚ùå Puede fallar si se usa en JavaScript sin TypeScript.

## üîÅ El tipo especial `this` en clases

En TypeScript, el tipo especial `this` hace referencia **din√°micamente al tipo de la clase actual**. Esto es √∫til, por ejemplo, cuando queremos que los m√©todos de una clase retornen la instancia concreta (subclase), no simplemente el tipo base.

### Ejemplo basico:

```go:ts
class Box {
  contents: string = "";

  set(value: string) {
    this.contents = value;
    return this;
  }
}
```

TypeScript **infiri√≥ que `set` retorna `this`**, no `Box`, lo que permite encadenamiento fluido incluso en subclases.

```go:ts
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();
const b = a.set("hello"); // b es de tipo ClearableBox, ¬°no Box!
```

---

## üì• Usar `this` como tipo de parametro

```go:ts
class Box {
  content: string = "";

  sameAs(other: this) {
    return other.content === this.content;
  }
}
```

Esto **difiere de usar `other: Box`**, ya que con `this`, la comparaci√≥n solo es v√°lida entre **instancias del mismo subtipo**.

```go:ts
class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();

derived.sameAs(base);
// ‚ùå Error: el par√°metro debe ser un DerivedBox, no un Box
```

---

## üß† Type Guards con `this`

Puedes crear **type guards personalizados** con `this is Tipo`, lo que permite a TypeScript **inferir din√°micamente el tipo** correcto al usar `if`.

```go:ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  isNetworked(): this is Networked & this {
    return this.networked;
  }

  constructor(public path: string, private networked: boolean) {}
}
```

Subclases:

```go:ts
class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[] = [];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {
  fso.content; // ‚úÖ fso es tratado como FileRep
} else if (fso.isDirectory()) {
  fso.children; // ‚úÖ fso es tratado como Directory
} else if (fso.isNetworked()) {
  fso.host; // ‚úÖ fso es Networked & FileSystemObject
}
```

---

## üîç Validacion perezosa con `this is`

```go:ts
class Box<T> {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box<string>();
box.value = "Gameboy";

if (box.hasValue()) {
  box.value; // ‚úÖ Tratado como `string`, no `string | undefined`
}
```

---

## üèóÔ∏è Propiedades de parametro

Puedes usar modificadores (`public`, `private`, `protected`, `readonly`) en los par√°metros del constructor para **declarar y asignar autom√°ticamente propiedades**:

```go:ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {}
}

const a = new Params(1, 2, 3);
console.log(a.x); // ‚úÖ

console.log(a.z); // ‚ùå Error: 'z' es privado
```

---

## üì¶ Expresiones de clase

Las **expresiones de clase** permiten definir clases an√≥nimas:

```go:ts
const someClass = class<Type> {
  content: Type;

  constructor(value: Type) {
    this.content = value;
  }
};

const m = new someClass("Hola mundo");
```

---

## üß± Firmas de constructor y `InstanceType`

Puedes usar `InstanceType<typeof Clase>` para referirte al tipo de una instancia creada con `new`:

```go:ts
class Point {
  createdAt = Date.now();
  constructor(public x: number, public y: number) {}
}

type PointInstance = InstanceType<typeof Point>;

function moveRight(point: PointInstance) {
  point.x += 5;
}
```

---

## üß© Clases y metodos abstractos

Una clase `abstract` **no se puede instanciar directamente** y puede tener miembros `abstract` que **deben implementarse en las subclases**.

```go:ts
abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hola, " + this.getName());
  }
}

class Derived extends Base {
  getName() {
    return "mundo";
  }
}

const d = new Derived();
d.printName(); // "Hola, mundo"
```

---

## üö´ Firmas abstractas de constructores

No puedes pasar una clase abstracta como argumento si luego haces `new ctor()`:

```go:ts
function greet(ctor: new () => Base) {
  const instance = new ctor();
  instance.printName();
}

greet(Derived); // ‚úÖ
greet(Base);    // ‚ùå Error: Base es abstracta
```

---

## üß¨ Relaciones entre clases

En TypeScript, las clases se **comparan estructuralmente**, no nominalmente. Dos clases con los mismos miembros se consideran compatibles:

```go:ts
class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

const p: Point1 = new Point2(); // ‚úÖ
```

Incluso sin herencia expl√≠cita, una clase puede ser subtipo de otra si contiene todos sus miembros:

```go:ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

const p: Person = new Employee(); // ‚úÖ
```

Clases vac√≠as (`class Empty {}`) **aceptan cualquier cosa** debido al sistema estructural:

```go:ts
class Empty {}

function fn(x: Empty) {}

fn(window); // ‚úÖ
fn({});     // ‚úÖ
fn(fn);     // ‚úÖ
```
